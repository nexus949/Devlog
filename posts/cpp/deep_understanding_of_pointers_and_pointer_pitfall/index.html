<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Deep understanding of Pointers and Pointer pitfall | Devlog</title>
<meta name="keywords" content="C&#43;&#43;">
<meta name="description" content="Pointers are easy ? Or are they ?
Pointers are pretty easy to use and understand unless we fall in deep dereferencing and more complex topics like array of pointers and multiple dereferences and incrementing or decrementing them.
Basic Pointer use:
int a = 3;
int* ptr = &amp;a;

std::cout &lt;&lt; a &lt;&lt; std::endl; //prints value of a
std::cout &lt;&lt; &amp;a &lt;&lt; std::endl; //prints address of a
std::cout &lt;&lt; ptr &lt;&lt; std::endl; //also prints address of a
std::cout &lt;&lt; *ptr &lt;&lt; std::endl; //prints value of a
Now lets go a little deep using pointer to a pointer.">
<meta name="author" content="">
<link rel="canonical" href="https://nexus949.github.io/Devlog/posts/cpp/deep_understanding_of_pointers_and_pointer_pitfall/">
<link crossorigin="anonymous" href="/Devlog/assets/css/stylesheet.653123a0ea74d41f2a457a31eed7257fccf817e8ddcf5292b9fe4995fc5d3f44.css" integrity="" rel="preload stylesheet" as="style">
<link rel="icon" href="https://nexus949.github.io/Devlog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://nexus949.github.io/Devlog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://nexus949.github.io/Devlog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://nexus949.github.io/Devlog/apple-touch-icon.png">
<link rel="mask-icon" href="https://nexus949.github.io/Devlog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://nexus949.github.io/Devlog/posts/cpp/deep_understanding_of_pointers_and_pointer_pitfall/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://nexus949.github.io/Devlog/posts/cpp/deep_understanding_of_pointers_and_pointer_pitfall/">
  <meta property="og:site_name" content="Devlog">
  <meta property="og:title" content="Deep understanding of Pointers and Pointer pitfall">
  <meta property="og:description" content="Pointers are easy ? Or are they ? Pointers are pretty easy to use and understand unless we fall in deep dereferencing and more complex topics like array of pointers and multiple dereferences and incrementing or decrementing them.
Basic Pointer use:
int a = 3; int* ptr = &amp;a; std::cout &lt;&lt; a &lt;&lt; std::endl; //prints value of a std::cout &lt;&lt; &amp;a &lt;&lt; std::endl; //prints address of a std::cout &lt;&lt; ptr &lt;&lt; std::endl; //also prints address of a std::cout &lt;&lt; *ptr &lt;&lt; std::endl; //prints value of a Now lets go a little deep using pointer to a pointer.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-07-05T17:51:59+05:30">
    <meta property="article:modified_time" content="2025-07-05T17:51:59+05:30">
    <meta property="article:tag" content="C&#43;&#43;">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Deep understanding of Pointers and Pointer pitfall">
<meta name="twitter:description" content="Pointers are easy ? Or are they ?
Pointers are pretty easy to use and understand unless we fall in deep dereferencing and more complex topics like array of pointers and multiple dereferences and incrementing or decrementing them.
Basic Pointer use:
int a = 3;
int* ptr = &amp;a;

std::cout &lt;&lt; a &lt;&lt; std::endl; //prints value of a
std::cout &lt;&lt; &amp;a &lt;&lt; std::endl; //prints address of a
std::cout &lt;&lt; ptr &lt;&lt; std::endl; //also prints address of a
std::cout &lt;&lt; *ptr &lt;&lt; std::endl; //prints value of a
Now lets go a little deep using pointer to a pointer.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://nexus949.github.io/Devlog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Deep understanding of Pointers and Pointer pitfall",
      "item": "https://nexus949.github.io/Devlog/posts/cpp/deep_understanding_of_pointers_and_pointer_pitfall/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Deep understanding of Pointers and Pointer pitfall",
  "name": "Deep understanding of Pointers and Pointer pitfall",
  "description": "Pointers are easy ? Or are they ? Pointers are pretty easy to use and understand unless we fall in deep dereferencing and more complex topics like array of pointers and multiple dereferences and incrementing or decrementing them.\nBasic Pointer use:\nint a = 3; int* ptr = \u0026amp;a; std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl; //prints value of a std::cout \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; std::endl; //prints address of a std::cout \u0026lt;\u0026lt; ptr \u0026lt;\u0026lt; std::endl; //also prints address of a std::cout \u0026lt;\u0026lt; *ptr \u0026lt;\u0026lt; std::endl; //prints value of a Now lets go a little deep using pointer to a pointer.\n",
  "keywords": [
    "C++"
  ],
  "articleBody": "Pointers are easy ? Or are they ? Pointers are pretty easy to use and understand unless we fall in deep dereferencing and more complex topics like array of pointers and multiple dereferences and incrementing or decrementing them.\nBasic Pointer use:\nint a = 3; int* ptr = \u0026a; std::cout \u003c\u003c a \u003c\u003c std::endl; //prints value of a std::cout \u003c\u003c \u0026a \u003c\u003c std::endl; //prints address of a std::cout \u003c\u003c ptr \u003c\u003c std::endl; //also prints address of a std::cout \u003c\u003c *ptr \u003c\u003c std::endl; //prints value of a Now lets go a little deep using pointer to a pointer.\nint a = 3; int* ptr = \u0026a; int** itr = \u0026ptr; std::cout \u003c\u003c itr \u003c\u003c std::endl; //prints address of ptr std::cout \u003c\u003c \u0026ptr \u003c\u003c std::endl; //also prints address of ptr std::cout \u003c\u003c *itr \u003c\u003c std::endl; //prints address of a since value at itr is ptr which is address of a std::cout \u003c\u003c **itr \u003c\u003c std::endl; //prints value of a, dereferencing once gives us the address of a i.e. \u0026a and further dereferencing that we get the value of a Now lets go a little more deep and try to understand pointer decay in arrays.\nLets say we got an array int arr[] = { 3, 7 }, now if we were to say int* ptr = \u0026arr[0], this will make ptr store the address of arr[0], but…if we were to pass arr to a function that expects a int* it will decay into a pointer, lets see:\nvoid func(int* arr){ //arr decays to a pointer pointing to the first element in the array std::cout \u003c\u003c *arr \u003c\u003c std::endl; } int main(){ int arr[] = { 3, 7 }; func(arr); } This is called a decay to a pointer !\nUnderstanding arrays a bit more deeply When we say int arr[] = { 3, 7 }, Its an array containing 2 integers ! Not A Pointer ! It is a variable of type int[2] ! Yes It is an special variable of type array containing 2 integers means it takes up 8 bytes in memory !\nThe decay only happens in specific situations like if passed to a function or doing pointer arithmetic !\nint is different from int[] !\nAn array is always of type type[N] where N is the number of elements in the array.\nThe main concept is that its all down to memory.\nSo, understanding that lets see another code snippet:\nint arr[] = { 3, 7 }; std::cout \u003c\u003c \u0026arr[0] \u003c\u003c std::endl; //prints the address of value at index 0 std::cout \u003c\u003c \u0026arr \u003c\u003c std::endl; //also prints the address of value at index 0 // BUT... int* ptr = \u0026arr; //This is wrong ! ❌ Results in a compile error int* ptr_2 = \u0026arr[0] //This is correct ! ✅ Compiles without any issue Lets see what’s happening here,\nptr expects address of a int but rather got address of an array, type int[2]. arr is an array and does not decay to a pointer here ! Meanwhile arr[0] is a valid int and passing its address to a int pointer is totally legal !\n❗ BUT WAIT….\nWhy does \u0026arr[0] and \u0026arr print the same address even if their types are NOT the same ?\nBecause \u0026arr gives the address to the whole block of array not just a singular int! \u0026arr will result in type (*)[N] //pointer to an array of N elements. If we were to do pointer arithmetic and add 1 to arr it will literally jump N bytes (8 in this case) ahead in memory, unlike \u0026arr[0] which will jump just 4 bytes if incremented by 1.\nWe can verify this by the following code snippet:\nint arr[] = { 3, 7 }; std::cout \u003c\u003c \u0026arr[0] \u003c\u003c std::endl; //prints the address of value at index 0 std::cout \u003c\u003c \u0026arr \u003c\u003c std::endl; //also prints the address of value at index 0 int (*ptr)[2] = \u0026arr; //declaring a pointer to an array of 2 elements int* val = \u0026arr[1]; //normal int pointer poiniting to index 1 element in the array std::cout \u003c\u003c ++ptr \u003c\u003c std::endl; //prints the address of the next byte after end of array. Jumped by N bytes(8 bytes in this case). std::cout \u003c\u003c ++val \u003c\u003c std::endl; //same prints the address of the next byte after the end of the array. Jumped by exactly 4 bytes Just a note: Doing \u0026arr or similar prevents decay to a pointer since we are explicitly taking out the address of arr. But doing this will result in a decay though:\nint arr[] = { 3, 7 }; int* ptr = arr; //decays to pointer to the first element i.e. arr[0] Alright, Lets move on to a little more complex topic, or pitfall ? Lets look at this snippet:\nint a = 1; int b = 2; int* arr[] = { \u0026a, \u0026b }; //array of pointers ! int** pp = arr; //pp is a pointer to a pointer pointing to arr[0]; ++**pp; //dereference pp to get VALUE of a i.e. 1 and increment it to 2; pp++; //increment pp by 1 to point to the next index ++**pp; //dereference pp to get teh VALUE of b i.e. 2 and increment it to 3; std::cout \u003c\u003c a \u003c\u003c \" \" \u003c\u003c b \u003c\u003c std::endl; //print values of a which is 2 and b which is 3. Now this is all good not such a pitfall, but a question asked by my cousin, why not do ++*p instead of pp++ ? Wont it cause pp to move to the next element in the array anyway ?\nGOOD QUESTION !\nLets see what’s happening ! pp points to arr[0] and doing pp++ makes it point to the next element i.e. arr[1], all good but lets see what ++*p does. It says dereference pp once and increment it by 1.\npp = `\u0026arr[0]. *pp = arr[0] = \u0026a. **pp = *(arr[0]) = *(\u0026a) = a = 1. All good so we now what *pp is, its \u0026a now lets say the address of a is 0x100 and that’s where pp point to, now doing ++*p will increment the pointer by 4 bytes since a is an int, now pp points to 0x104 which is a garbage address ! Therefore, doing **pp now will result in printing of a garbage value !\nBut Why is b not next to a ? Isn’t it stored in an array and arrays are contiguous blocks of memory ? (This is actually my question).\nThe Answer: Yes, Arrays store in contiguous blocks of memory but a and b themselves are not stored rather their addresses, means their address stored as values are contiguous. See first 2 lines a and b are initialized independently they can be anywhere in the stack not necessarily next to each other !\nLets see one more topic… Look at this code snippet:\nint arr[] = { 3, 7 }; int* ptr = arr; //decays to pointer and points to arr[0] ptr += 1; //will increment ptr to point to arr[1] arr += 1 //Error ❌ Will not compile Why so ?\nBecause arr is NOT a pointer, its an ARRAY ! U cannot do arr = arr + 1. U can do arr[0 + 1] but not the earlier ! Why ? Because decay to a pointer only happens if its an rvalue !\nint* ptr = arr here arr is an rvalue and we got a valid lvalue that can bind to it therefore it can decay to a pointer. Doing std::cout \u003c\u003c *arr \u003c\u003c std::endl is also valid std::cout knows how to handle a rvalue ! This is the very reason ! arr = arr + 1 cannot happen because the lvalue is an array and NOT a pointer !\nWell here is something from ChatGPT : template\u003ctypename T, std::size_t N\u003e void foo(T (\u0026arr)[N]) That looks cursed !\nLets see what’s going On :\nA template with a type T and N with size std::size_t (Don’t exactly know the gist of this size_t).\nA function prototype accepting an array of type T and passed as reference therefore the whole array will be passed without decaying into a pointer. Doing a sizeof() will return N and not just the size of the pointer !\n",
  "wordCount" : "1374",
  "inLanguage": "en",
  "datePublished": "2025-07-05T17:51:59+05:30",
  "dateModified": "2025-07-05T17:51:59+05:30",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://nexus949.github.io/Devlog/posts/cpp/deep_understanding_of_pointers_and_pointer_pitfall/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Devlog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://nexus949.github.io/Devlog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top"><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Overpass:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://nexus949.github.io/Devlog/" accesskey="h" title="Devlog (Alt + H)">Devlog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://github.com/nexus949" title="Github">
                    <span>Github</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://nexus949.github.io/Devlog/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Deep understanding of Pointers and Pointer pitfall
    </h1>
    <div class="post-meta"><span title='2025-07-05 17:51:59 +0530 IST'>July 5, 2025</span>

</div>
  </header> 
  <div class="post-content"><h3 id="pointers-are-easy--or-are-they-">Pointers are easy ? Or are they ?<a hidden class="anchor" aria-hidden="true" href="#pointers-are-easy--or-are-they-">#</a></h3>
<p>Pointers are pretty easy to use and understand unless we fall in deep dereferencing and more complex topics like array of pointers and multiple dereferences and incrementing or decrementing them.</p>
<p>Basic Pointer use:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> ptr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">//prints value of a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">&amp;</span>a <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">//prints address of a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> ptr <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">//also prints address of a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>ptr <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">//prints value of a
</span></span></span></code></pre></div><p>Now lets go a little deep using pointer to a pointer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> ptr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">**</span> itr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>ptr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> itr <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">//prints address of ptr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">&amp;</span>ptr <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">//also prints address of ptr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>itr <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">//prints address of a since value at itr is ptr which is address of a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">**</span>itr <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">//prints value of a, dereferencing once gives us the address of a i.e. &amp;a and further dereferencing that we get the value of a
</span></span></span></code></pre></div><p>Now lets go a little more deep and try to understand pointer decay in arrays.</p>
<p>Lets say we got an array <code>int arr[] = { 3, 7 }</code>, now if we were to say <code>int* ptr = &amp;arr[0]</code>, this will make <code>ptr</code> store the address of <code>arr[0]</code>, but&hellip;if we were to pass <code>arr</code> to a function that expects a <code>int*</code> it will decay into a pointer, lets see:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> arr){
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//arr decays to a pointer pointing to the first element in the array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>arr <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">int</span> arr[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span> };
</span></span><span style="display:flex;"><span>	func(arr);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is called a decay to a pointer !</p>
<h4 id="understanding-arrays-a-bit-more-deeply">Understanding arrays a bit more deeply<a hidden class="anchor" aria-hidden="true" href="#understanding-arrays-a-bit-more-deeply">#</a></h4>
<p>When we say <code>int arr[] = { 3, 7 }</code>, Its an array containing 2 integers ! <strong>Not A Pointer !</strong>
It is a variable of type <code>int[2]</code> ! Yes It is an special variable of type array containing 2 integers means it takes up <code>8 bytes</code> in memory !</p>
<p>The decay only happens in specific situations like if passed to a function or doing pointer arithmetic !</p>
<p><strong><code>int</code> is different from <code>int[]</code> !</strong></p>
<p>An array is always of type <code>type[N]</code> where <code>N</code> is the number of elements in the array.</p>
<p><strong>The main concept is that its all down to memory.</strong></p>
<p>So, understanding that lets see another code snippet:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> arr[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">&amp;</span>arr[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">//prints the address of value at index 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">&amp;</span>arr <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">//also prints the address of value at index 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// BUT...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> ptr <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>arr; <span style="color:#75715e">//This is wrong ! ❌ Results in a compile error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> ptr_2 <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>arr[<span style="color:#ae81ff">0</span>] <span style="color:#75715e">//This is correct ! ✅ Compiles without any issue
</span></span></span></code></pre></div><p>Lets see what&rsquo;s happening here,</p>
<p><code>ptr</code> expects address of a <code>int</code> but rather got address of an array, type <code>int[2]</code>. <code>arr</code> is an array and does not decay to a pointer here ! Meanwhile <code>arr[0]</code> is a valid <code>int</code> and passing its address to a <code>int</code> pointer is totally legal !</p>
<p>❗ BUT WAIT&hellip;.</p>
<p>Why does <code>&amp;arr[0]</code> and <code>&amp;arr</code> print the same address even if their types are <strong>NOT</strong> the same ?</p>
<p>Because <code>&amp;arr</code> gives the address to the whole block of array not just a singular <code>int</code>! <code>&amp;arr</code> will result in type <code>(*)[N] //pointer to an array of N elements</code>. If we were to do pointer arithmetic and add <code>1</code> to <code>arr</code> it will literally jump <code>N</code> bytes (8 in this case) ahead in memory, unlike <code>&amp;arr[0]</code> which will jump just 4 bytes if incremented by 1.</p>
<p>We can verify this by the following code snippet:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> arr[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">&amp;</span>arr[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">//prints the address of value at index 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">&amp;</span>arr <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">//also prints the address of value at index 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>ptr)[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>arr; <span style="color:#75715e">//declaring a pointer to an array of 2 elements
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> val <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>arr[<span style="color:#ae81ff">1</span>]; <span style="color:#75715e">//normal int pointer poiniting to index 1 element in the array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">++</span>ptr <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">//prints the address of the next byte after end of array. Jumped by N bytes(8 bytes in this case).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">++</span>val <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">//same prints the address of the next byte after the end of the array. Jumped by exactly 4 bytes
</span></span></span></code></pre></div><p>Just a note: Doing <code>&amp;arr</code> or similar prevents decay to a pointer since we are explicitly taking out the address of <code>arr</code>. But doing this will result in a decay though:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> arr[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span> };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> ptr <span style="color:#f92672">=</span> arr; <span style="color:#75715e">//decays to pointer to the first element i.e. arr[0]
</span></span></span></code></pre></div><h3 id="alright-lets-move-on-to-a-little-more-complex-topic-or-pitfall-">Alright, Lets move on to a little more complex topic, or pitfall ?<a hidden class="anchor" aria-hidden="true" href="#alright-lets-move-on-to-a-little-more-complex-topic-or-pitfall-">#</a></h3>
<p>Lets look at this snippet:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> arr[] <span style="color:#f92672">=</span> { <span style="color:#f92672">&amp;</span>a, <span style="color:#f92672">&amp;</span>b }; <span style="color:#75715e">//array of pointers !
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">**</span> pp <span style="color:#f92672">=</span> arr; <span style="color:#75715e">//pp is a pointer to a pointer pointing to arr[0];
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">++**</span>pp; <span style="color:#75715e">//dereference pp to get VALUE of a i.e. 1 and increment it to 2;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>pp<span style="color:#f92672">++</span>;   <span style="color:#75715e">//increment pp by 1 to point to the next index
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">++**</span>pp; <span style="color:#75715e">//dereference pp to get teh VALUE of b i.e. 2 and increment it to 3;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> a <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">&lt;&lt;</span> b <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">//print values of a which is 2 and b which is 3.
</span></span></span></code></pre></div><p>Now this is all good not such a pitfall, but a question asked by my cousin, why not do <code>++*p</code> instead of <code>pp++</code> ? Wont it cause <code>pp</code> to move to the next element in the array anyway ?</p>
<p><em>GOOD QUESTION !</em></p>
<p>Lets see what&rsquo;s happening !
<code>pp</code> points to <code>arr[0]</code> and doing <code>pp++</code> makes it point to the next element i.e. <code>arr[1]</code>, all good but lets see what <code>++*p</code> does. It says dereference <code>pp</code> once and increment it by 1.</p>
<ul>
<li><code>pp</code> = `&amp;arr[0].</li>
<li><code>*pp</code> = <code>arr[0]</code> = <code>&amp;a</code>.</li>
<li><code>**pp</code> = <code>*(arr[0])</code> = <code>*(&amp;a)</code> = <code>a</code> = <code>1</code>.</li>
</ul>
<p>All good so we now what <code>*pp</code> is, its <code>&amp;a</code> now lets say the address of <code>a</code> is <code>0x100</code> and that&rsquo;s where <code>pp</code> point to, now doing <code>++*p</code> will increment the pointer by 4 bytes since <code>a</code> is an <code>int</code>, now <code>pp</code> points to <code>0x104</code> which is a garbage address ! Therefore, doing <code>**pp</code> now will result in printing of a garbage value !</p>
<p>But Why is <code>b</code> not next to <code>a</code> ? Isn&rsquo;t it stored in an array and arrays are contiguous blocks of memory ? (<em>This is actually my question</em>).</p>
<p>The Answer: Yes, Arrays store in contiguous blocks of memory but <code>a</code> and <code>b</code> themselves are not stored rather their addresses, means their address stored as values are contiguous. See first 2 lines <code>a</code> and <code>b</code> are initialized independently they can be anywhere in the stack not necessarily next to each other !</p>
<h3 id="lets-see-one-more-topic">Lets see one more topic&hellip;<a hidden class="anchor" aria-hidden="true" href="#lets-see-one-more-topic">#</a></h3>
<p>Look at this code snippet:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> arr[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span> };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> ptr <span style="color:#f92672">=</span> arr; <span style="color:#75715e">//decays to pointer and points to arr[0]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>ptr <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">//will increment ptr to point to arr[1]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>arr <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> <span style="color:#75715e">//Error ❌ Will not compile
</span></span></span></code></pre></div><p>Why so ?</p>
<p>Because <code>arr</code> is <strong>NOT</strong> a pointer, its an <strong>ARRAY</strong> ! U cannot do <code>arr = arr + 1</code>. U can do <code>arr[0 + 1]</code> but not the earlier ! Why ? Because decay to a pointer only happens if its an <code>rvalue</code> !</p>
<ul>
<li><code>int* ptr = arr</code> here <code>arr</code> is an <code>rvalue</code> and we got a valid <code>lvalue</code> that can bind to it therefore it can decay to a pointer.</li>
<li>Doing <code>std::cout &lt;&lt; *arr &lt;&lt; std::endl</code> is also valid <code>std::cout</code> knows how to handle a <code>rvalue</code> !</li>
</ul>
<p>This is the very reason ! <code>arr = arr + 1</code> cannot happen because the <code>lvalue</code> is an array and <strong>NOT</strong> a pointer !</p>
<h3 id="well-here-is-something-from-chatgpt-">Well here is something from ChatGPT :<a hidden class="anchor" aria-hidden="true" href="#well-here-is-something-from-chatgpt-">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, std<span style="color:#f92672">::</span>size_t N<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">void</span> foo(T (<span style="color:#f92672">&amp;</span>arr)[N])
</span></span></code></pre></div><p>That looks cursed !</p>
<p>Lets see what&rsquo;s going On :</p>
<p>A template with a type <code>T</code> and <code>N</code> with size <code>std::size_t</code> (Don&rsquo;t exactly know the gist of this <code>size_t</code>).</p>
<p>A function prototype accepting an array of type <code>T</code> and passed as reference therefore the whole array will be passed without decaying into a pointer. Doing a <code>sizeof()</code> will return <code>N</code> and not just the size of the pointer !</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://nexus949.github.io/Devlog/tags/c&#43;&#43;/">C&#43;&#43;</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://nexus949.github.io/Devlog/">Devlog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
